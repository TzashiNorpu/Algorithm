package algo.tzashinorpu.FirstRound.Chapter12.HomeWork;

public class LeetCode_5_552 {
    public int checkRecord1(int n) {
        /* dp[i][j][k]等于第i天，在缺席了j次，以及连续迟到了k次的情况下，还可以拿到奖励的出席排列的数量。
        dp[i][0][0]：今天截止0次缺席，今天截止0连续迟到。
        dp[i][0][1]：今天截止0次缺席，今天截止1连续迟到。
        dp[i][0][2]：今天截止0次缺席，今天截止2连续迟到。
        dp[i][1][0]：今天截止1次缺席，今天截止0连续迟到。
        dp[i][1][1]：今天截止1次缺席，今天截止1连续迟到。
        dp[i][1][2]：今天截止1次缺席，今天截止2连续迟到。

        缺席累计  迟到在当天不迟到情况下可以重置

        dp[i][0][0] = dp[i - 1][0][0] + dp[i - 1][0][1] + dp[i - 1][0][2] 。
        今天截止0次缺席，今天截止0次连续迟到：过去一定也是0次缺席，但过去可以有0，1，2次连续迟到，因为只要我今天按时出席，过去的迟到记录都一笔勾销。

        dp[i][1][0] = dp[i - 1][1][0] + dp[i - 1][1][1] + dp[i - 1][1][2] + dp[i - 1][0][0] + dp[i - 1][0][1] + dp[i - 1][0][2]
        今天截止1次缺席，今天截止0次连续迟到：分两种情况：今天缺席和过去缺席
        a. 前三项，代表过去有1次缺席，今天没有缺席，但过去可以有0，1，2次连续迟到，因为只要我今天按时出席，过去的迟到记录都一笔勾销。
        b. 后三项，代表过去有0次缺席，今天缺席了，但过去可以有0，1，2次连续迟到，因为只要我今天不迟到（缺席也是不迟到），过去的迟到记录都一笔勾销。

        dp[i][0][1] = dp[i - 1][0][0];  过去迟到，今天不迟到则清零，因此只有今天迟到的情况
        今天截止0次缺席，今天截止1次连续迟到：过去0次缺席，过去0次迟到，今天迟到了。

        dp[i][0][2] = dp[i - 1][0][1];
        今天截止0次缺席，今天截止2次连续迟到：过去0次缺席，昨天迟到，今天迟到了。

        dp[i][1][1] = dp[i - 1][1][0];
        今天截止1次缺席，今天截止1次连续迟到：过去1次缺席，过去0次迟到，今天迟到了。这里可以仔细想一下，我今天必须要迟到，所以今天截止的1次缺席必定来自过去。

        dp[i][1][2] = dp[i - 1][1][1];
        今天截止1次缺席，今天截止2次连续迟到：过去1次缺席，昨天迟到，今天迟到了。
        */
        int Mod = 1000000007;
        long[][][] dp = new long[n + 1][2][3];
        dp[0][0][0] = 1;
        for (int i = 1; i <= n; i++) {
            dp[i][0][0] = (dp[i - 1][0][0] + dp[i - 1][0][1] + dp[i - 1][0][2]) % Mod;
            dp[i][1][0] = (dp[i - 1][1][0] + dp[i - 1][1][1] + dp[i - 1][1][2] + dp[i - 1][0][0] + dp[i - 1][0][1] + dp[i - 1][0][2]) % Mod;
            dp[i][0][1] = (dp[i - 1][0][0]);
            dp[i][0][2] = (dp[i - 1][0][1]);
            dp[i][1][1] = (dp[i - 1][1][0]);
            dp[i][1][2] = (dp[i - 1][1][1]);
        }
        return (int) ((dp[n][0][0] + dp[n][0][1] + dp[n][0][2] + dp[n][1][0] + dp[n][1][1] + dp[n][1][2]) % Mod);
    }

    public int checkRecord2(int n) {
        long a = 1, b = 0, c = 0, d = 0, e = 0, f = 0;
        int Mod = 1000000007;
        for (int i = 0; i < n; i++) {
            long tmpA = a + b + c;
            long tmpD = a + b + c + d + e + f;
            c = b;
            b = a;
            f = e;
            e = d;
            a = tmpA;
            d = tmpD;
            a %= Mod;
            b %= Mod;
            c %= Mod;
            d %= Mod;
            e %= Mod;
            f %= Mod;
        }
        return (int) ((a + b + c + d + e + f) % Mod);
    }
}
